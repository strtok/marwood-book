[cell]: https://github.com/strtok/marwood/blob/master/marwood/src/cell.rs
[parser]: https://github.com/strtok/marwood/blob/master/marwood/src/parse.rs
[lexer]: https://github.com/strtok/marwood/blob/master/marwood/src/lex.rs
[sexpr]: https://en.wikipedia.org/wiki/S-expression

# Parsing & Printing

## Introduction

Scheme, having an incredibly simple grammar, lends itself well to a hand-written lexer and parser.

Marwood's parser is composed of three separate components:

* the `Cell` object, which represents a [sexpr] (or Scheme's AST) in Rust

* the `lexer` (or scanner or tokenizer), which is responsible for turning plain-text scheme into a list of tokens to be consumed by Marwood's `parser`.

* the `parser`, which is responsible for constructing an aggregate structure called `Cell` from the lexer output

## Cell

[Cell] is the enum type that represents Scheme sexpr's in Rust. It is the main input to Marwood's compiler, macro transformers, and printer, and is the output of Marwood's VM as a result of evaluating scheme.

Cell is an enum. Most of the variants represent `atom` types in Scheme, such as boolean values, numbers, characters, and strings:

```rust,noplayground
pub enum Cell {
    Bool(bool),
    Char(char),
    Number(Number),
    Nil,
    String(String),
    Symbol(String),
}
```

As an example, parsing the scheme expression `#f` would result in Marwood's parser outputting the value `Cell::Bool(false)`.

Cell also contains a few variants that provide aggregate types support for scheme pairs, lists and vectors:

```rust,noplayground
pub enum Cell {
    ...
    Pair(Box<Cell>, Box<Cell>),
    Vector(Vec<Cell>),
}
```

`Pair` is a pair of Cells representing the `car` and `cdr` parts of a cons pair. This structure can be used to represent pairs in scheme, which in turn may be used to represent lists. This is the main building block for representing Scheme code's tree structure in Rust.

`Vector` represents a scheme vector, such as `#(10 20 30)`.

The Cell enum also contains a few variants that can only be produced as output of Marwood's evaluator. For example, the `Cell::Void` variant is produced by some Marwood procedures that evaluate to `#<void>` (e.g. define, set!). It is not possible to produce these variants via Marwood's parser.

```rust,noplayground
#[derive(Debug, Eq, PartialEq, Hash, Clone)]
pub enum Cell {
    ...
    Continuation,
    Macro,
    Procedure(Option<String>),
    Undefined,
    Void,
}

```

## Lexing

Marwood's [lexer] is in the form:

```rust,noplayground 
fn scan(text: &str) -> Result<Vec<Token>, Error>
```

Given scheme code as input, the scan function returns a vector of tokens according to the Scheme grammar Each token contains a span, which may be used to extract the token's text from the source text, and the token type (e.g. LeftParen).

```rust,noplayground
pub struct Token {
    /// (start, end) index of original span in the source &str
    pub span: (usize, usize),
    /// The type output by the scanner
    pub token_type: TokenType,
}

pub enum TokenType {
    Char,
    Dot,
    False,
    LeftParen,
    Number,
    NumberPrefix,
    RightParen,
    SingleQuote,
    String,
    Symbol,
    True,
    WhiteSpace,
    HashParen,
}
```

### Error::Incomplete

The special error `Error::Incomplete` is returned in certain circumstances where the input looks incomplete, and may be hint to the REPL interface that the user intends to enter a multi-line expression.

An example that may cause an `Error::Incomplete` error in Marwood's scanner is a mismatched double quote: `"hello world`.

### Scanner Example

Given this code:

```'(10 20 "puppies") ; heterogeneous```

The tokenizer will produce the following tokens:

```
[
    Token {
        span: (0, 1),
        token_type: SingleQuote,
    },
    Token {
        span: (1, 2),
        token_type: LeftParen,
    },
    Token {
        span: (2,4),
        token_type: Number,
    },
    Token {
        span: (5,7),
        token_type: Number,
    },
    Token {
        span: (8,17),
        token_type: String,
    },
    Token {
        span: (17,18),
        token_type: RightParen,
    }
]
```

## Parsing